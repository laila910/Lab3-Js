<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solve as Comments for part 3
    </title>
</head>
<body>
  
<script>
//  ## EX 1:Use 10 of Objects predefined methods and explain them.

 /*  1- Object.create() method creates a new object, using an existing object as the prototype of the newly created object.
Example of how to use it :*/
const person = {
    isHuman: false,
    printIntroduction: function() {
      console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
    }
  };
  
  const me = Object.create(person);
  
  me.name = 'Matthew'; // "name" is a property set on "me", but not on "person"
  me.isHuman = true; // inherited properties can be overwritten
  
  me.printIntroduction();
  // expected output: "My name is Matthew. Am I human? true"
//   ---------------------------------------------------------------------------------
/*
2- The Object.assign() method copies all enumerable own properties from one or more source objects to a target object. 
It returns the modified target object. Example of how to use it:
*/
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target);
// expected output: Object { a: 1, b: 4, c: 5 }

console.log(returnedTarget);
// expected output: Object { a: 1, b: 4, c: 5 }
// -------------------------------------------------------------------------------------------------------------
/*
3- The Object.hasOwn() static method returns true if the specified object has the indicated property as its own property.
 If the property is inherited, or does not exist, the method returns false. Example of how to use it:

*/
const object1 = {
  prop: 'exists'
};

console.log(Object.hasOwn(object1, 'prop'));
// expected output: true

console.log(Object.hasOwn(object1, 'toString'));
// expected output: false

console.log(Object.hasOwn(object1, 'undeclaredPropertyValue'));
// expected output: false

/*
//--------------------------------------------------------------------------------------------------------------------
4- The Object.is() method determines whether two values are the same value. Example of how to use it:
Syntax: 
    Object.is(value1, value2);

Parameters:
value1 -> The first value to compare.

value2 -> The second value to compare.

Return value: 
A Boolean indicating whether or not the two arguments are the same value.
*/
// Case 1: Evaluation result is the same as using ===
Object.is(25, 25);                // true
Object.is('foo', 'foo');          // true
Object.is('foo', 'bar');          // false
Object.is(null, null);            // true
Object.is(undefined, undefined);  // true
Object.is(window, window);        // true
Object.is([], []);                // false
var foo = { a: 1 };
var bar = { a: 1 };
Object.is(foo, foo);              // true
Object.is(foo, bar);              // false

// Case 2: Signed zero
Object.is(0, -0);                 // false
Object.is(+0, -0);                // false
Object.is(-0, -0);                // true
Object.is(0n, -0n);               // true

// Case 3: NaN
Object.is(NaN, 0/0);              // true
Object.is(NaN, Number.NaN)        // true
//--------------------------------------------------------------------------------------------------------------------------
/*
5- The Object.keys() method returns an array of a given object's own enumerable property names, iterated in 
the same order that a normal loop would. Example of how using it:

*/

const object5 = {
  a: 'somestring',
  b: 42,
  c: false
};

console.log(Object.keys(object5));
// expected output: Array ["a", "b", "c"]
// ---------------------------------------------------------------------------------------------------------------------------
/*
6- The Object.values() method returns an array of a given object's own enumerable property values,
 in the same order as that provided by a for...in loop. (The only difference is that a for...in loop
  enumerates properties in the prototype chain as well.). Example of how to using it:
*/
const object6 = {
  a: 'somestring',
  b: 42,
  c: false
};

console.log(Object.values(object6));
// expected output: Array ["somestring", 42, false]
//----------------------------------------------------------------------------------------------------------------------------
/*
7- The toString() method returns a string representing the object. Example of how to use it:*/
function Dog(name) {
  this.name = name;
}

const dog1 = new Dog('Gabby');

Dog.prototype.toString = function dogToString() {
  return `${this.name}`;
};

console.log(dog1.toString());
// expected output: "Gabby"
//----------------------------------------------------------------------------------------------------------------------------
/*
8- The Object.freeze() method freezes an object. A frozen object can no longer be changed; freezing an object prevents 
new properties from being added to it, existing properties from being removed, prevents changing the enumerability,
 configurability, or writability of existing properties, and prevents the values of existing properties from being changed. 
 In addition, freezing an object also prevents its prototype from being changed. freeze() returns the same object that was passed in.
*/
const obj = {
  prop: 42
};

Object.freeze(obj);

obj.prop = 33;
// Throws an error in strict mode

console.log(obj.prop);
// expected output: 42
//---------------------------------------------------------------------------------------------------------------------------
/*
9- The Object.isFrozen() determines if an object is frozen. Example of using it:
*/
const object9 = {
  property1: 42
};

console.log(Object.isFrozen(object9));
// expected output: false

Object.freeze(object9);

console.log(Object.isFrozen(object9));
// expected output: true
//-------------------------------------------------------------------------------------------------------------------------
/*
10- The Object.seal() method seals an object, preventing new properties from being added to it and marking all existing
 properties as non-configurable. Values of present properties can still be changed as long as they are writable.
*/
const object10 = {
  property1: 42
};

Object.seal(object10);
object1.property1 = 33;
console.log(object10.property1);
// expected output: 33

delete object10.property1; // cannot delete when sealed
console.log(object10.property1);
// expected output: 33
//---------------------------------------------------------------------------------------------------------------------------

//  ## Ex 2 :Use 10 of Arrays predefined methods and explain them.
/*
1- The at() method takes an integer value and returns the item at that index, allowing for positive and negative integers.
 Negative integers count back from the last item in the array. This is not to suggest there is anything wrong with using the 
 square bracket notation. For example array[0] would return the first item. However instead of using array.length for latter
  items; e.g. array[array.length-1] for the last item, you can call array.at(-1)
*/
const array1 = [5, 12, 8, 130, 44];

let index = 2;

console.log(`Using an index of ${index} the item returned is ${array1.at(index)}`);
// expected output: "Using an index of 2 the item returned is 8"

index = -2;

console.log(`Using an index of ${index} item returned is ${array1.at(index)}`);
// expected output: "Using an index of -2 item returned is 130"

//----------------------------------------------------------------------------------------------------------------------------
/*
2- The concat() method is used to merge two or more arrays. This method does not change 
the existing arrays, but instead returns a new array.
*/
const array12= ['a', 'b', 'c'];
const array2 = ['d', 'e', 'f'];
const array3 = array12.concat(array2);

console.log(array3);
// expected output: Array ["a", "b", "c", "d", "e", "f"]
//----------------------------------------------------------------------------------------------------------------------------
/*
3- The every() method tests whether all elements in the array pass the test implemented by the provided function.
 It returns a Boolean value.

*/
const isBelowThreshold = (currentValue) => currentValue < 40;

const array33 = [1, 30, 39, 29, 10, 13];

console.log(array33.every(isBelowThreshold));
// expected output: true
//---------------------------------------------------------------------------------------------------------------------------
/*
4- The filter() method creates a new array with all elements that pass the test implemented by the provided function.

*/
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word => word.length > 6);

console.log(result);
// expected output: Array ["exuberant", "destruction", "present"]
//----------------------------------------------------------------------------------------------------------------------------
/*
5- The find() method returns the first element in the provided array that satisfies the provided testing function. 
If no values satisfy the testing function, undefined is returned.
*/
const array5 = [5, 12, 8, 130, 44];

const found = array5.find(element => element > 10);

console.log(found);
// expected output: 12
//-----------------------------------------------------------------------------------------------------------------------------
/*
6- The findIndex() method returns the index of the first element in the array that satisfies the provided testing function.
 Otherwise, it returns -1, indicating that no element passed the test.
*/
const array6 = [5, 12, 8, 130, 44];

const isLargeNumber = (element) => element > 13;

console.log(array6.findIndex(isLargeNumber));
// expected output: 3
//-----------------------------------------------------------------------------------------------------------------------------
/* 
7- The forEach() method executes a provided function once for each array element.
*/
const array7 = ['a', 'b', 'c'];

array7.forEach(element => console.log(element));

// expected output: "a"
// expected output: "b"
// expected output: "c"
//---------------------------------------------------------------------------------------------------------------------------
/*
8- The Array.from() static method creates a new, shallow-copied Array instance from an array-like or iterable object.

*/
console.log(Array.from('foo'));
// expected output: Array ["f", "o", "o"]

console.log(Array.from([1, 2, 3], x => x + x));
// expected output: Array [2, 4, 6]
//-----------------------------------------------------------------------------------------------------------------------------
/*
9- The includes() method determines whether an array includes a certain value among its entries, 
returning true or false as appropriate.

*/
const array9 = [1, 2, 3];

console.log(array9.includes(2));
// expected output: true

const pets = ['cat', 'dog', 'bat'];

console.log(pets.includes('cat'));
// expected output: true

console.log(pets.includes('at'));
// expected output: false
//------------------------------------------------------------------------------------------------------------------------------
/*
10- The indexOf() method returns the first index at which a given element can be found in the array, or -1 if it is not present.

*/
const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];

console.log(beasts.indexOf('bison'));
// expected output: 1

// start from index 2
console.log(beasts.indexOf('bison', 2)); //search from index 2
// expected output: 4

console.log(beasts.indexOf('giraffe')); 
// expected output: -1 // means it's not found
//-------------------------------------------------------------------------------------------------------------------------
// ## Ex3: Write a nested function and explain the closure -> lexical environment.
// Lexical scope is an important part of closures, but it is not a closure by itself.
// Closures are an advanced concept that is also a frequent topic of technical interviews.
// Lexical scope describes how nested (also known as "child") functions have access to variables defined in parent scopes.
const myFunction = () => {
     let myValue = 2;
     console.log(myValue);  // 2

     const childFunction = () => {
          console.log(myValue += 1); // (2 + 1 = 3)
     }

     childFunction();
}

myFunction();
// In this example, childFunction has access to the variable myValue which is defined in the parent scope of myFunction.
// The lexical scope of childFunction allows access to the parent scope.

// A closure is a function having access to the parent scope, even after the parent function has closed.
// Let's note the first part of the sentence before the comma:
// ...a function having access to the parent scope
// That's describing lexical scope!
// But we need the second part of the definition to give an example of a closure...
// ...even after the parent function has closed.
// Let's look at an example of a closure:

const myFunction2 = () => {
     let myValue = 2;
     console.log(myValue); // 2

     const childFunction = () => {
          console.log(myValue += 1);
     }

     return childFunction;
}

const res = myFunction2();
console.log(res); // () => {      console.log(myValue += 1); }
res(); // 3
res(); // 4
res(); // 5 
// In this revision, myFunction returns childFunction instead of calling it.
// Therefore, when result is set equal to myFunction(), the console statement 
// inside myFunction is logged, but not the statement inside childFunction.
// childFunction is not called into action.
// Instead, it is returned and held in result.
// In addition, we need to realize that myFunction has closed after it was called.
// The line with console.log(result) should show in the console that result now 
// holds the anonymous function value that was childFunction.
// Now, when we call result(), we are calling the anonymous function that was assigned to childFunction.
// As a child of myFunction, this anonymous function has access to the myValue variable
//  inside myFunction even after it has closed!
// The closure we created now allows us to continue to increase the value of the myValue variable every time we call result().
</script>

    
</body>
</html>